---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Welcome to Astro.">
	<main>
	</main>
</Layout>

<script>
	let shouldScrollToBottom = false;
	let scrollonce = false;

	document.getElementById('skiptobutton')?.addEventListener('click', () => {
		shouldScrollToBottom = true;
		scrollonce = true;
	});

	function rgbToHex(r, g, b) {
		const toHex = (c) => c.toString(16).padStart(2, '0');
		return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
	}

	async function copyToClipboard(text) {
		try {
			await navigator.clipboard.writeText(text);
		} catch (err) {
			console.error('Unable to copy text to clipboard', err);
		}
	}

	function formatTime(seconds) {
		const days = Math.floor(seconds / (24 * 3600));
		const hours = Math.floor((seconds % (24 * 3600)) / 3600);
		const minutes = Math.floor((seconds % 3600) / 60);
		const secs = Math.floor(seconds % 60);
		return `${String(days).padStart(2, '0')}:${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
	}

	function generateColors() {
		const colorContainer = document.body;
		let i = 0, j = 0, k = 0, id = 0, l = 16581375;
		let avgRate = 0;
		const smoothing = 0.2;
		const batchSize = 100; // Reduced from 500 to reduce lag
		let frameCount = 0; // For averaging time estimates
		let totalElapsed = 0;

		function loop() {
			const start = performance.now();
			const fragment = document.createDocumentFragment();

			for (let n = 0; n < batchSize && i <= 255; n++) {
				const hexColor = rgbToHex(i, j, k);
				const colorBox = document.createElement('div');
				colorBox.className = 'color-box';
				colorBox.style.backgroundColor = hexColor;
				colorBox.innerText = hexColor;
				colorBox.id = String(++id);
				colorBox.addEventListener('click', () => copyToClipboard(hexColor));
				fragment.appendChild(colorBox);

				k++;
				if (k > 255) { k = 0; j++; }
				if (j > 255) { j = 0; i++; }
			}

			colorContainer.appendChild(fragment);

			if (shouldScrollToBottom) {
				window.scrollTo({ top: document.body.scrollHeight });
				if (scrollonce) {
					shouldScrollToBottom = false;
					scrollonce = false;
				}
			}

			const elapsed = (performance.now() - start) / 1000;
			totalElapsed += elapsed;
			frameCount++;
			avgRate = (batchSize * frameCount) / totalElapsed;

			if (frameCount % 10 === 0) { // Update every 10 frames to save CPU
				const remaining = l / avgRate;
				const tl = document.getElementById('tl');
				if (tl) tl.innerText = formatTime(remaining);
			}

			if (i <= 255) requestAnimationFrame(loop);
		}

		loop();
	}

	generateColors();
</script>
